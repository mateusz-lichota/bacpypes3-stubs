"""
This type stub file was generated by pyright.
"""

import argparse
import asyncio
import dataclasses
from typing import (
    Any as _Any,
    Callable,
    Dict,
    List,
    Optional,
    TYPE_CHECKING,
    Tuple,
    Union,
)
from .apdu import APDU, IAmRequest
from .appservice import ApplicationServiceAccessPoint
from .basetypes import (
    ObjectPropertyReference,
    PropertyReference,
    Segmentation,
    ServicesSupported,
)
from .comm import ApplicationServiceElement
from .debugging import DebugContents, bacpypes_debugging
from .netservice import (
    NetworkServiceAccessPoint,
    NetworkServiceElement,
    RouterInfoCache,
)
from .object import DeviceObject, Object
from .pdu import Address
from .primitivedata import ObjectIdentifier
from .service.cov import ChangeOfValueServices
from .service.device import WhoHasIHaveServices, WhoIsIAmServices
from .service.object import (
    ReadRangeServices,
    ReadWritePropertyMultipleServices,
    ReadWritePropertyServices,
)
from .vendor import VendorInfo

"""
Application Module
"""
if TYPE_CHECKING:
    APDUFuture = asyncio.Future[Optional[APDU]]
else: ...
_debug = ...
_log = ...
property_index_re = ...

@dataclasses.dataclass
class DeviceInfo(DebugContents):
    _debug_contents = ...
    device_instance: int
    device_address: Address
    max_apdu_length_accepted: int = ...
    segmentation_supported: Segmentation = ...
    vendor_identifier: Optional[int] = ...
    max_segments_accepted: Optional[int] = ...
    max_npdu_length: Optional[int] = ...
    protocol_services_supported: Optional[ServicesSupported] = ...

class DeviceInfoCache(DebugContents):
    _debug_contents = ...
    _debug: Callable[..., None]
    address_cache: Dict[Address, DeviceInfo]
    instance_cache: Dict[int, DeviceInfo]
    def __init__(self, device_info_class=...) -> None: ...
    async def get_device_info(
        self, addr: Union[Address, int]
    ) -> Optional[DeviceInfo]: ...
    async def set_device_info(self, apdu: IAmRequest):  # -> DeviceInfo:
        """
        Create/update a device information record based on the contents of an
        IAmRequest and put it in the cache.
        """
        ...

    def update_device_info(self, device_info: DeviceInfo):  # -> None:
        """
        Update a device information record based on what was changed
        from the APCI information from the segmentation state
        machine.
        """
        ...

    def acquire(self, device_info: DeviceInfo) -> None:
        """
        This function is called by the segmentation state machine when it
        will be using the device information.
        """
        ...

    def release(self, device_info: DeviceInfo) -> None:
        """
        This function is called by the segmentation state machine when it
        has finished with the device information.
        """
        ...

class Application(
    ApplicationServiceElement,
    WhoIsIAmServices,
    WhoHasIHaveServices,
    ReadWritePropertyServices,
    ReadWritePropertyMultipleServices,
    ReadRangeServices,
    ChangeOfValueServices,
):
    _debug: Callable[..., None]
    _exception: Callable[..., None]
    _startup_disabled = ...
    asap: ApplicationServiceAccessPoint
    nsap: NetworkServiceAccessPoint
    nse: NetworkServiceElement
    device_object: Optional[DeviceObject] = ...
    device_info_cache: DeviceInfoCache
    objectName: Dict[str, _Any]
    objectIdentifier: Dict[ObjectIdentifier, _Any]
    link_layers: Dict[ObjectIdentifier, _Any]
    next_invoke_id: int
    _requests: Dict[Address, List[Tuple[APDU, APDUFuture]]]
    def __init__(
        self,
        device_object: DeviceObject,
        device_info_cache: Optional[DeviceInfoCache] = ...,
        *args,
        **kwargs,
    ) -> None: ...
    @classmethod
    def from_object_list(
        cls,
        objects: List[Object],
        device_info_cache: Optional[DeviceInfoCache] = ...,
        router_info_cache: Optional[RouterInfoCache] = ...,
        aseID=...,
    ) -> Application:
        """
        Create an instance of an Application given a list of objects.
        """
        ...

    @classmethod
    def from_json(
        cls,
        objects: List[Dict[str, _Any]],
        device_info_cache: Optional[DeviceInfoCache] = ...,
        router_info_cache: Optional[RouterInfoCache] = ...,
        aseID=...,
    ) -> Application:
        """
        Create an instance of an Application after converting the objects
        from JSON objects to BACpypes objects.
        """
        ...

    @classmethod
    def from_args(
        cls,
        args: argparse.Namespace,
        device_info_cache: Optional[DeviceInfoCache] = ...,
        router_info_cache: Optional[RouterInfoCache] = ...,
        aseID=...,
    ) -> Application: ...
    def add_object(self, obj):  # -> None:
        """Add an object to the application."""
        ...

    def delete_object(self, obj):  # -> None:
        """Add an object to the local collection."""
        ...

    def get_object_id(self, objid):  # -> Any:
        """Return a local object or None."""
        ...

    def get_object_name(self, objname):  # -> Any:
        """Return a local object or None."""
        ...

    def iter_objects(self):  # -> Iterator[Any]:
        """Iterate over the objects."""
        ...

    def get_services_supported(self):  # -> BitString:
        """Return a ServicesSupported bit string based in introspection, look
        for helper methods that match confirmed and unconfirmed services."""
        ...

    async def get_device_info(
        self, addr: Union[Address, int]
    ) -> Optional[DeviceInfo]: ...
    async def get_vendor_info(
        self,
        *,
        device_instance: Optional[int] = ...,
        device_address: Optional[Address] = ...,
        vendor_identifier: Optional[int] = ...,
    ) -> VendorInfo: ...
    async def parse_object_identifier(
        self,
        arg: Union[int, str, tuple],
        *,
        device_instance: Optional[int] = ...,
        device_address: Optional[Address] = ...,
        vendor_identifier: Optional[int] = ...,
        vendor_info: Optional[VendorInfo] = ...,
    ) -> ObjectIdentifier: ...
    async def parse_property_reference(
        self,
        arg: Union[int, str, tuple],
        *,
        device_instance: Optional[int] = ...,
        device_address: Optional[Address] = ...,
        vendor_identifier: Optional[int] = ...,
        vendor_info: Optional[VendorInfo] = ...,
    ) -> PropertyReference: ...
    async def parse_object_property_reference(
        self,
        object_identifier: Union[int, str, tuple],
        property_reference: Union[int, str],
        *,
        device_instance: Optional[int] = ...,
        device_address: Optional[Address] = ...,
        vendor_identifier: Optional[int] = ...,
        vendor_info: Optional[VendorInfo] = ...,
    ) -> ObjectPropertyReference: ...
    def close(self):  # -> None:
        """
        Close the applications link layer objects.
        """
        ...

    def request(self, apdu: APDU) -> APDUFuture:
        """
        This function is called by a subclass of Application when it has a
        confirmed or unconfirmed request to send.  It returns a future that
        will have the acknowledgement/error/reject/abort set as the result.

        If the APDU does not have an invoke ID set it will be assigned one, and
        it will be reassigned to a new one if there is already an outstanding
        request with the same one.

        There is no throttling of the number of outstanding requests.
        """
        ...

    async def indication(self, apdu) -> None:
        """
        This function is called when the application service element has
        an incoming request that should be processed by the application.
        """
        ...

    async def response(self, apdu: APDU) -> None:
        """This function is called by the application when it has a response to
        an incoming confirmed service."""
        ...

    async def confirmation(self, apdu: APDU) -> None:
        """This function is called when application is receiving the response
        from sending a confirmed service request."""
        ...
