"""
This type stub file was generated by pyright.
"""

import asyncio
from typing import Callable, Dict, List, Optional, Set, TYPE_CHECKING, Tuple, Union
from .debugging import DebugContents, bacpypes_debugging
from .comm import ApplicationServiceElement, Client, Server, ServiceAccessPoint
from .pdu import Address, PDU
from .npdu import IAmRouterToNetwork, InitializeRoutingTableAck, NPDU
from .basetypes import RouterEntryStatus

"""
Network Service
"""
if TYPE_CHECKING:
    WhatIsNetworkNumberFuture = asyncio.Future[int]
else:
    ...
_debug = ...
_log = ...
WHO_IS_ROUTER_TO_NETWORK_TIMEOUT = ...
INITIALIZE_ROUTING_TABLE_TIMEOUT = ...
ROUTER_AVAILABLE = ...
ROUTER_BUSY = ...
ROUTER_DISCONNECTED = ...
@bacpypes_debugging
class RouterInfoCache(DebugContents):
    """
    This class provides an in-memory implementation of the network topology.
    """
    _debug_contents = ...
    _debug: Callable[..., None]
    router_dnets: Dict[Tuple[Optional[int], Address], Set[int]]
    path_info: Dict[Tuple[Optional[int], int], Tuple[Address, RouterEntryStatus]]
    def __init__(self) -> None:
        ...
    
    async def get_path_info(self, snet: Optional[int], dnet: int) -> Optional[Tuple[Address, int]]:
        """
        Given a source network and a destination network, return a tuple of
        the router address and the status of the router to the destination
        network.
        """
        ...
    
    async def set_path_info(self, snet: Optional[int], dnet: int, address: Address, status: RouterEntryStatus) -> bool:
        """
        Given a source network and a destination network, set the router
        address and the status of the router to the destination network.
        Return false if the cached value has not changed.
        """
        ...
    
    async def delete_path_info(self, snet: Optional[int], dnet: int) -> bool:
        """
        Given a source network and a destination network, delete the cache
        info.  Return false if the cache has not changed.
        """
        ...
    
    async def get_router_dnets(self, snet: Optional[int], address: Address) -> Optional[Set[int]]:
        """
        Given a source network and the address of a router, return the list
        of destination networks reachable through the router or None if
        there is no cache entry.
        """
        ...
    
    async def set_router_dnets(self, snet: Optional[int], address: Address, dnets: Set[int]) -> bool:
        """
        Given a source network, router address, and list of destination
        networks update the cache.  Return False if the cache value has not
        changed.
        """
        ...
    
    async def delete_router_dnets(self, snet: Optional[int], address: Address) -> bool:
        """
        Given a source network and router address delete the cache entry.
        Return False if the cache value has not changed.
        """
        ...
    
    async def update_path_info(self, snet: Optional[int], address: Address, dnets: Set[int]) -> None:
        ...
    
    async def remove_path_info(self, snet: int, address: Optional[Address] = ..., dnets: Optional[Set[int]] = ...) -> None:
        """
        Given a source network, optional router address and optional list of
        destination networks, remove the path information.
        """
        ...
    
    async def update_router_status(self, snet: int, address: Address, status: RouterEntryStatus) -> None:
        ...
    
    async def update_source_network(self, old_snet: int, new_snet: int) -> None:
        """
        This method is called when the network number for an adapter becomes
        known, the Network-Number-Is service.
        """
        ...
    


@bacpypes_debugging
class NetworkAdapter(Client[PDU], DebugContents):
    _debug: Callable[..., None]
    _debug_contents = ...
    adapterSAP: NetworkServiceAccessPoint
    adapterNet: Optional[int]
    adapterAddr: Optional[Address]
    adapterNetConfigured: int
    def __init__(self, sap: NetworkServiceAccessPoint, net: Optional[int] = ..., addr: Optional[Address] = ..., cid=...) -> None:
        ...
    
    async def confirmation(self, pdu: PDU) -> None:
        """Decode upstream PDUs and pass them up to the service access point."""
        ...
    
    async def process_npdu(self, npdu: NPDU) -> None:
        """Encode NPDUs from the service access point and send them downstream."""
        ...
    
    def EstablishConnectionToNetwork(self, net): # -> None:
        ...
    
    def DisconnectConnectionToNetwork(self, net): # -> None:
        ...
    


@bacpypes_debugging
class NetworkServiceAccessPoint(ServiceAccessPoint, Server[PDU], DebugContents):
    _debug: Callable[..., None]
    _warning: Callable[..., None]
    _debug_contents = ...
    adapters: Dict[Union[int, None], NetworkAdapter]
    local_adapter: Optional[NetworkAdapter]
    router_info_cache: RouterInfoCache
    def __init__(self, router_info_cache: Optional[RouterInfoCache] = ..., sap: Optional[str] = ..., sid: Optional[str] = ...) -> None:
        ...
    
    def bind(self, server: Server[PDU], net: Optional[int] = ..., address: Optional[Address] = ...) -> None:
        """Create a network adapter object and bind.

        bind(s, None, None)
            Called for simple applications, local network unknown, no specific
            address, APDUs sent upstream

        bind(s, net, None)
            Called for routers, bind to the network, (optionally?) drop APDUs

        bind(s, None, address)
            Called for applications or routers, bind to the network (to be
            discovered), send up APDUs with a matching address

        bind(s, net, address)
            Called for applications or routers, bind to the network, send up
            APDUs with a matching address.
        """
        ...
    
    async def update_router_references(self, snet: int, address: Address, dnets: List[int]) -> None:
        """
        Update references to routers, called when I-Am-Router-To-Network is
        received.  Also called to load the router info cache during application
        startup if necessary.
        """
        ...
    
    async def delete_router_references(self, snet: int, address: Optional[Address] = ..., dnets: Optional[Set[int]] = ...) -> None:
        """
        Delete references to routers/networks.
        """
        ...
    
    async def indication(self, pdu: PDU) -> None:
        ...
    
    async def process_npdu(self, adapter: NetworkAdapter, npdu: NPDU) -> None:
        ...
    
    async def sap_indication(self, adapter: NetworkAdapter, npdu: NPDU) -> None:
        ...
    
    async def sap_confirmation(self, adapter: NetworkAdapter, npdu: NPDU) -> None:
        ...
    


@bacpypes_debugging
class WhoIsRouterToNetworkFuture:
    """
    Instances of this class are used to track Who-Is-Router-To-Network requests
    and responses.
    """
    _debug: Callable[..., None]
    nse: NetworkServiceElement
    adapter: Optional[NetworkAdapter]
    router_address: Optional[Address]
    network: Optional[int]
    future: asyncio.Future
    result_list: List[Tuple[NetworkAdapter, IAmRouterToNetwork]]
    def __init__(self, nse: NetworkServiceElement, adapter: Optional[NetworkAdapter] = ..., router_address: Optional[Address] = ..., network: Optional[int] = ...) -> None:
        ...
    
    def match(self, adapter, npdu: IAmRouterToNetwork) -> None:
        """
        This function is called for each incoming IAmRouterToNetwork to see if
        it matches the criteria.
        """
        ...
    
    def who_is_router_to_network_done(self, future: asyncio.Future) -> None:
        """The future has been completed or canceled."""
        ...
    
    def who_is_router_to_network_timeout(self): # -> None:
        """The timeout has elapsed, save the I-Am messages we found in the
        future."""
        ...
    


@bacpypes_debugging
class InitializeRoutingTableFuture:
    """
    Instances of this class are used to track Who-Is-Router-To-Network requests
    and responses.
    """
    _debug: Callable[..., None]
    nse: NetworkServiceElement
    adapter: Optional[NetworkAdapter]
    router_address: Optional[Address]
    future: asyncio.Future
    result_list: List[Tuple[NetworkAdapter, InitializeRoutingTableAck]]
    def __init__(self, nse: NetworkServiceElement, adapter: Optional[NetworkAdapter] = ..., router_address: Optional[Address] = ...) -> None:
        ...
    
    def match(self, adapter, npdu: InitializeRoutingTableAck) -> None:
        """
        This function is called for each incoming InitializeRoutingTableAck to
        see if it matches the criteria.
        """
        ...
    
    def done(self, future: asyncio.Future) -> None:
        """The future has been completed or canceled."""
        ...
    
    def timeout(self): # -> None:
        """The timeout has elapsed, save the I-Am messages we found in the
        future."""
        ...
    


@bacpypes_debugging
class NetworkServiceElement(ApplicationServiceElement, DebugContents):
    _debug: Callable[..., None]
    _debug_contents: Tuple[str, ...] = ...
    _startup_disabled = ...
    who_is_router_to_network_futures: List[WhoIsRouterToNetworkFuture]
    initialize_routing_table_futures: List[InitializeRoutingTableFuture]
    what_is_network_number_resolution: Dict[NetworkAdapter, WhatIsNetworkNumberFuture]
    def __init__(self, eid=...) -> None:
        ...
    
    def startup(self): # -> None:
        ...
    
    async def indication(self, adapter: NetworkAdapter, npdu: NPDU) -> None:
        ...
    
    async def confirmation(self, adapter: NetworkAdapter, npdu: NPDU) -> None:
        ...
    
    def who_is_router_to_network(self, adapter: Optional[NetworkAdapter] = ..., destination: Optional[Address] = ..., network: Optional[int] = ...) -> asyncio.Future:
        ...
    
    async def i_am_router_to_network(self, adapter: Optional[NetworkAdapter] = ..., destination: Optional[Address] = ..., network: Optional[int] = ...) -> None:
        ...
    
    def what_is_network_number(self, adapter: Optional[NetworkAdapter] = ..., destination: Optional[Address] = ...) -> asyncio.Future:
        """
        Request the network number, optionally for a specific adapter, and if
        adapter is provided then send the request to a specific address.
        """
        ...
    
    async def network_number_is(self, adapter=...) -> None:
        """
        This function initiates a Network-Number-Is broadcast to a specific
        adapter or to all of the adapters.  If the request is for all of the
        adapters, only those that have the network number 'configured' will
        be broadcast.
        """
        ...
    
    def initialize_routing_table(self, adapter: Optional[NetworkAdapter] = ..., destination: Optional[Address] = ...) -> asyncio.Future:
        """
        Send an "empty" Initialize-Routing-Table message to a device, return
        a list of (adapter, InitializeRoutingTableAck) tuples.
        """
        ...
    
    async def WhoIsRouterToNetwork(self, adapter, npdu): # -> None:
        ...
    
    async def IAmRouterToNetwork(self, adapter, npdu): # -> None:
        ...
    
    async def ICouldBeRouterToNetwork(self, adapter, npdu): # -> None:
        ...
    
    async def RejectMessageToNetwork(self, adapter, npdu): # -> None:
        ...
    
    async def RouterBusyToNetwork(self, adapter, npdu): # -> None:
        ...
    
    async def RouterAvailableToNetwork(self, adapter, npdu): # -> None:
        ...
    
    async def InitializeRoutingTable(self, adapter, npdu): # -> None:
        ...
    
    async def InitializeRoutingTableAck(self, adapter, npdu): # -> None:
        ...
    
    async def EstablishConnectionToNetwork(self, adapter, npdu): # -> None:
        ...
    
    async def DisconnectConnectionToNetwork(self, adapter, npdu): # -> None:
        ...
    
    async def WhatIsNetworkNumber(self, adapter, npdu): # -> None:
        ...
    
    def NetworkNumberIs(self, adapter, npdu): # -> None:
        ...
    


