"""
This type stub file was generated by pyright.
"""

from typing import (
    Any as _Any,
    Callable,
    Dict,
    FrozenSet,
    List as _List,
    Optional,
    Set,
    TextIO,
    Tuple,
    Union,
)
from .debugging import DebugContents, bacpypes_debugging
from .primitivedata import Element, ElementInterface, ElementMetaclass, TagList

"""
Constructed Data
"""
_debug = ...
_log = ...
_sequence_type_signatures: Dict[FrozenSet[Tuple[str, _Any]], type] = ...
_sequence_of_classes: Set[type] = ...
_array_type_signatures: Dict[FrozenSet[Tuple[str, _Any]], type] = ...
_array_of_classes: Set[type] = ...
_list_type_signatures: Dict[FrozenSet[Tuple[str, _Any]], type] = ...
_list_of_classes: Set[type] = ...

class SequenceMetaclass(ElementMetaclass):
    """
    Amazing documentation here.
    """

    _debug: Callable[..., None]
    _type_signatures: Dict[FrozenSet[Tuple[str, _Any]], type] = ...
    _structures: Set[type] = ...
    def __new__(
        cls: _Any,
        clsname: str,
        superclasses: Tuple[type, ...],
        attributedict: Dict[str, _Any],
    ) -> SequenceMetaclass: ...
    def __call__(cls, *args: _Any, **kwargs: _Any) -> Sequence: ...

class Sequence(Element, DebugContents, metaclass=SequenceMetaclass):
    """
    Amazing documentation here.
    """

    _debug: Callable[..., None]
    _debug_contents: Tuple[str, ...]
    _elements: Dict[str, _Any]
    _inits: Dict[str, _Any]
    _order: Tuple[str, ...]
    def __init__(
        self, arg: Union[Sequence, Dict[str, _Any], None] = ..., **kwargs: _Any
    ) -> None: ...
    def __getattr__(self, attr: str) -> _Any: ...
    def __setattr__(self, attr: str, value: _Any) -> None: ...
    @classmethod
    def cast(cls: type, arg: _Any) -> _Any:
        """Return a sequence object with values copied from arg."""
        ...

    def encode(self) -> TagList:
        """Encode a sequence as a tag list."""
        ...

    @classmethod
    def decode(cls, tag_list: TagList, class_: Optional[type] = ...) -> Sequence:
        """Decode a sequence from a tag list."""
        ...

    def __eq__(self, other: _Any) -> bool:
        """Compare two sequences for equality."""
        ...

    def __ne__(self, other: _Any) -> bool: ...
    def __hash__(self) -> int: ...

class Choice(Sequence):
    """
    Amazing documentation here.
    """

    _debug: Callable[..., None]
    _choice: Optional[str] = ...
    def __init__(
        self, arg: Union[Choice, Dict[str, _Any], None] = ..., **kwargs: _Any
    ) -> None: ...
    def __setattr__(self, attr: str, value: _Any) -> None: ...
    def encode(self) -> TagList:
        """Encode a choice as a tag list."""
        ...

    @classmethod
    def decode(cls, tag_list: TagList) -> Choice:  # pyright: ignore[reportIncompatibleMethodOverride]
        """Decode a choice from a tag list."""
        ...

class ExtendedListMetaclass(type):
    """
    Amazing documentation here.
    """

    _debug: Callable[..., None]
    def __call__(cls, *args: _Any, **kwargs: _Any) -> _Any: ...

class ExtendedList(list[_Any], ElementInterface, metaclass=ExtendedListMetaclass):
    """
    Amazing documentation here.
    """

    _debug: Callable[..., None]
    _subtype: type
    def __init__(self, *args: _Any, **kwargs: _Any) -> None: ...
    def append(self, item: _Any) -> None: ...
    def __getitem__(self, item: Union[int, slice]) -> _Any:  # pyright: ignore[reportIncompatibleMethodOverride]
        ...
    def __setitem__(self, item: Union[int, slice], value: _Any) -> None:  # pyright: ignore[reportIncompatibleMethodOverride]
        ...
    @classmethod
    def cast(cls: type, arg: _Any) -> _Any:
        """Return a sequence object with values copied from arg."""
        ...

    def encode(self) -> TagList:
        """Encode an extended list as a tag list."""
        ...

    @classmethod
    def decode(cls, tag_list: TagList) -> ExtendedList:
        """Decode a choice from a tag list."""
        ...

def SequenceOf[T: type](cls: T, **kwargs: _Any) -> T:
    """
    Amazing documentation here.
    """
    ...

class List(ExtendedList):
    """
    Amazing documentation here.
    """

    _debug: Callable[..., None]
    def __init__(self, *args: _Any, **kwargs: _Any) -> None: ...

def ListOf[T: type](cls: T, **kwargs: _Any) -> T:
    """
    Function to return a class that can encode and decode a list of
    some other type.
    """
    ...

class ArrayMetaclass(ExtendedListMetaclass):
    """
    Amazing documentation here.
    """

    _debug: Callable[..., None]
    def __call__(cls, *args: _Any, **kwargs: _Any) -> _Any: ...

class Array(ExtendedList, metaclass=ArrayMetaclass):
    """
    Amazing documentation here.
    """

    _debug: Callable[..., None]
    _init: Optional[_Any] = ...
    _length: Optional[int] = ...
    def __init__(self, *args: _Any, **kwargs: _Any) -> None: ...
    def append(self, item: _Any) -> None: ...
    def __getitem__(self, item: Union[int, slice]) -> _Any: ...
    def __setitem__(self, item: Union[int, slice], value: _Any) -> None: ...
    def __delitem__(self, item: _Any) -> None: ...
    @classmethod
    async def read_property(  # pyright: ignore[reportIncompatibleMethodOverride]
        cls, getter: Callable[[], _Any], index: Optional[int] = ...
    ) -> _Any: ...
    @classmethod
    async def write_property(  # pyright: ignore[reportIncompatibleMethodOverride]
        cls,
        getter: Callable[[], _Any],
        setter: Callable[[_Any], _Any],
        value: _Any,
        index: Optional[int] = ...,
        priority: Optional[int] = ...,
    ) -> None: ...

def ArrayOf[T: type](cls: T, **kwargs: _Any) -> T:
    """
    Amazing documentation here.
    """
    ...

class Any(Element):
    """
    Amazing documentation here.
    """

    _debug: Callable[..., None]
    tagList: Optional[TagList]
    def __init__(
        self,
        arg: Optional[TagList] = ...,
        _optional: Optional[bool] = ...,
        _context: Optional[int] = ...,
    ) -> None: ...
    @classmethod
    def cast(cls: type, arg: _Any) -> _Any:
        """Return a valid value for the class."""
        ...

    def encode(self) -> TagList:
        """Encode an any element as a tag list."""
        ...

    @classmethod
    def decode(cls, tag_list: TagList) -> _Any:
        """Decode an element from a tag list."""
        ...

    def cast_in(self, element: Element) -> None:
        """..."""
        ...

    def cast_out(self, cls: type, null: bool = ...) -> _Any:
        """
        Given the tag list, decode the contents as an object of type `cls`.
        Null is acceptable when decoding the property value of a Write Property
        Request and the priority has been provided.
        """
        ...

    def get_value_type(self) -> type:
        """Return the datatype encoded in the Any iff possible."""
        ...

    def __eq__(self, other: _Any) -> bool:
        """Compare two Any for equality."""
        ...

    def __ne__(self, other: _Any) -> bool: ...
    def debug_contents(
        self, indent: int = ..., file: TextIO = ..., _ids: Optional[_List[_Any]] = ...
    ) -> None: ...

class AnyAtomic(Any):
    """
    Amazing documentation here.
    """

    _debug: Callable[..., None]
    tagList: Optional[TagList]
    def __init__(
        self,
        arg: Optional[TagList] = ...,
        _optional: Optional[bool] = ...,
        _context: Optional[int] = ...,
    ) -> None: ...
    @classmethod
    def cast(cls: type, arg: _Any) -> _Any:
        """Return a valid value for the class."""
        ...

    def encode(self) -> TagList:
        """Encode an any element as a tag list."""
        ...

    @classmethod
    def decode(cls, tag_list: TagList) -> _Any:
        """Decode an element from a tag list."""
        ...

    def cast_in(self, element: Element) -> None:
        """..."""
        ...

    def cast_out(self, cls: type) -> _Any:  # pyright: ignore[reportIncompatibleMethodOverride]
        """..."""
        ...

    def get_value(self) -> _Any:
        """Return the value encoded in the type."""
        ...

    def get_value_type(self) -> type:
        """Return the datatype encoded in the Any iff possible."""
        ...
