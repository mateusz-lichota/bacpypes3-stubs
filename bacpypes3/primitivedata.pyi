"""
This type stub file was generated by pyright.
"""

import datetime
from enum import IntEnum
from typing import Any as _Any, Callable, Dict, FrozenSet, Iterable, Iterator, List as _List, Optional, TextIO, Tuple, Union
from .debugging import bacpypes_debugging
from .pdu import PDUData

"""
Primitive Data Types
"""
_debug = ...
_log = ...
_unupper_re = ...
_trailing_uppers_re = ...
_wordsplit_re = ...
def attr_to_asn1(k): # -> str:
    """
    Translate enumeration names like 'analogValue' into 'analog-value'.
    """
    ...

class TagClass(IntEnum):
    application = ...
    context = ...
    opening = ...
    closing = ...


class TagNumber(IntEnum):
    null = ...
    boolean = ...
    unsigned = ...
    integer = ...
    real = ...
    double = ...
    octetString = ...
    characterString = ...
    bitString = ...
    enumerated = ...
    date = ...
    time = ...
    objectIdentifier = ...
    reserved13 = ...
    reserved14 = ...
    reserved15 = ...


class Tag:
    """
    Amazing documentation here.
    """
    tag_class: TagClass
    tag_number: Union[TagNumber, int]
    tag_lvt: int
    tag_data: bytes
    _app_tag_name = ...
    _app_tag_class: _List[type]
    def __init__(self, *args: _Any) -> None:
        ...
    
    def set(self, tclass: TagClass, tnum: Union[int, TagNumber], tlvt: int = ..., tdata: bytes = ...) -> None:
        """Set the attributes of the tag."""
        ...
    
    def set_app_data(self, tnum: TagNumber, tdata: bytes) -> None:
        """Set the attributes of the tag as an application tag."""
        ...
    
    def encode(self) -> PDUData:
        """Encode a tag on the end of the PDU."""
        ...
    
    @classmethod
    def decode(cls, pdu_data: PDUData) -> Tag:
        """Decode a tag from the PDU."""
        ...
    
    def app_to_context(self, context: int) -> Tag:
        """Return a context tag from an application tag."""
        ...
    
    def context_to_app(self, tag_number: TagNumber) -> Tag:
        """Return an application tag from a context tag."""
        ...
    
    def app_to_object(self) -> Union[Atomic, None]:
        """Return the application object encoded by the tag."""
        ...
    
    def __repr__(self) -> str:
        ...
    
    def __eq__(self, tag: _Any) -> bool:
        """Tags are equal if all the attributes are equal."""
        ...
    
    def __ne__(self, arg: _Any) -> bool:
        """Inverse of __eq__."""
        ...
    
    def debug_contents(self, indent: int = ..., file: TextIO = ..., _ids: Optional[_List[_Any]] = ...) -> None:
        ...
    


class ApplicationTag(Tag):
    """
    Amazing documentation here.
    """
    def __init__(self, *args: _Any) -> None:
        ...
    


class ContextTag(Tag):
    """
    Amazing documentation here.
    """
    def __init__(self, context: int, data: Union[bytes, bytearray]) -> None:
        ...
    


class OpeningTag(Tag):
    """
    Amazing documentation here.
    """
    def __init__(self, context: int) -> None:
        ...
    


class ClosingTag(Tag):
    """
    Amazing documentation here.
    """
    def __init__(self, context: int) -> None:
        ...
    


class TagList(Iterable):
    """
    Amazing documentation here.
    """
    tagList: _List[Tag]
    def __init__(self, arg: Union[_List[Tag], TagList, PDUData, None] = ...) -> None:
        ...
    
    def append(self, tag: Tag) -> None:
        ...
    
    def extend(self, taglist: Iterable[Tag]) -> None:
        ...
    
    def __getitem__(self, item: int) -> Tag:
        ...
    
    def __len__(self) -> int:
        ...
    
    def __iter__(self) -> Iterator[Tag]:
        ...
    
    def __eq__(self, other: object) -> bool:
        """Tag lists are equal if all the tags are equal."""
        ...
    
    def __ne__(self, arg: _Any) -> bool:
        """Inverse of __eq__."""
        ...
    
    def peek(self) -> Union[Tag, None]:
        """Return the tag at the front of the list."""
        ...
    
    def push(self, tag: Tag) -> None:
        """Return a tag back to the front of the list."""
        ...
    
    def pop(self) -> Union[Tag, None]:
        """Remove the tag from the front of the list and return it."""
        ...
    
    def pop_context(self) -> TagList:
        """Return a list of one application or context encoded tag, or a list
        of tags with matching opening/closing pairs.
        """
        ...
    
    def encode(self) -> PDUData:
        """Encode the tag list."""
        ...
    
    @classmethod
    def decode(cls, pdu_data: PDUData) -> TagList:
        """Decode a list of tags from PDU data."""
        ...
    
    def debug_contents(self, indent: int = ..., file: TextIO = ..., _ids: Optional[_List[_Any]] = ...) -> None:
        ...
    


@bacpypes_debugging
class ElementMetaclass(type):
    """
    Amazing documentation here.
    """
    _debug: Callable[..., None]
    _type_signatures: Dict[FrozenSet[Tuple[str, _Any]], type] = ...
    _signature_parameters = ...
    def __new__(cls: _Any, clsname: str, superclasses: Tuple[type, ...], attributedict: Dict[str, _Any]) -> ElementMetaclass:
        ...
    
    def __call__(cls, *args: _Any, **kwargs: _Any) -> Union[ElementMetaclass, Element]:
        ...
    


@bacpypes_debugging
class ElementInterface:
    """
    Amazing documentation here.
    """
    _debug: Callable[..., None]
    _signature: FrozenSet[Tuple[str, _Any]] = ...
    _optional: Optional[bool] = ...
    _context: Optional[int] = ...
    @classmethod
    def get_attribute(cls, getter: Callable[[], _Any]) -> _Any:
        ...
    
    @classmethod
    def set_attribute(cls, getter: Callable[[], _Any], setter: Callable[[_Any], None], value: _Any) -> None:
        ...
    
    @classmethod
    def cast(cls: type, arg: _Any) -> _Any:
        """Return True if arg is valid value for the class."""
        ...
    
    @classmethod
    async def read_property(cls, getter: Optional[Callable[[], _Any]], index: Optional[int] = ...) -> _Any:
        ...
    
    @classmethod
    async def write_property(cls, getter: Callable[[], _Any], setter: Optional[Callable[[_Any], _Any]], value: _Any, index: Optional[int] = ..., priority: Optional[int] = ...) -> None:
        ...
    
    def encode(self) -> TagList:
        """Encode the element as a tag list."""
        ...
    
    @classmethod
    def decode(cls, tag_list: TagList) -> ElementInterface:
        """Decode an element from a tag list."""
        ...
    


class Element(ElementInterface, metaclass=ElementMetaclass):
    ...


@bacpypes_debugging
class Atomic(Element):
    """
    Amazing documentation here.
    """
    _debug: Callable[..., None]
    _value: _Any = ...
    def __init__(self, *args: _Any, _optional: Optional[bool] = ..., _context: Optional[int] = ..., **kwargs: _Any) -> None:
        ...
    


@bacpypes_debugging
class Null(Atomic, tuple):
    """
    Amazing documentation here.
    """
    _debug: Callable[..., None]
    @classmethod
    def cast(cls: type, arg: _Any) -> _Any:
        """Return True if arg is valid value for the class."""
        ...
    
    def encode(self) -> TagList:
        """Encode a null element as a tag list."""
        ...
    
    @classmethod
    def decode(cls, tag_list: TagList) -> Null:
        """Decode an element from a tag list."""
        ...
    


@bacpypes_debugging
class Boolean(Atomic, int):
    """
    Note that this is a subclass of the int built-in type, bool cannot be.
    """
    _debug: Callable[..., None]
    def __init__(self, *args: bool, _optional: Optional[bool] = ..., _context: Optional[int] = ...) -> None:
        ...
    
    @classmethod
    def cast(cls: type, arg: _Any) -> _Any:
        """Return True if arg is valid value for the class."""
        ...
    
    def encode(self) -> TagList:
        """Encode a null element as a tag list."""
        ...
    
    @classmethod
    def decode(cls, tag_list: TagList) -> Boolean:
        """Decode an element from a tag list."""
        ...
    


@bacpypes_debugging
class Unsigned(Atomic, int):
    """
    Amazing documentation here.
    """
    _debug: Callable[..., None]
    _base: Optional[int] = ...
    _low_limit: Optional[int] = ...
    _high_limit: Optional[int] = ...
    @classmethod
    def cast(cls: type, arg: _Any) -> _Any:
        """Return True if arg is valid value for the class."""
        ...
    
    def encode(self) -> TagList:
        """Encode an unsigned element as a tag list."""
        ...
    
    @classmethod
    def decode(cls, tag_list: TagList) -> Unsigned:
        """Decode an unsigned element from a tag list."""
        ...
    


class Unsigned8(Unsigned):
    """
    Amazing documentation here.
    """
    _high_limit = ...


class Unsigned16(Unsigned):
    """
    Amazing documentation here.
    """
    _high_limit = ...


@bacpypes_debugging
class Integer(Atomic, int):
    """
    Amazing documentation here.
    """
    _debug: Callable[..., None]
    _base: Optional[int] = ...
    _low_limit: Optional[int] = ...
    _high_limit: Optional[int] = ...
    @classmethod
    def cast(cls: type, arg: _Any) -> _Any:
        """Return True if arg is valid value for the class."""
        ...
    
    def encode(self) -> TagList:
        """Encode an integer as a tag list."""
        ...
    
    @classmethod
    def decode(cls, tag_list: TagList) -> Integer:
        """Decode an integer from a tag list."""
        ...
    


@bacpypes_debugging
class Real(Atomic, float):
    """
    Amazing documentation here.
    """
    _debug: Callable[..., None]
    _low_limit: Optional[float] = ...
    _high_limit: Optional[float] = ...
    @classmethod
    def cast(cls: type, arg: _Any) -> _Any:
        """Return True if arg is valid value for the class."""
        ...
    
    def encode(self) -> TagList:
        """Encode a real as a tag list."""
        ...
    
    @classmethod
    def decode(cls, tag_list: TagList) -> Real:
        """Decode a real from a tag list."""
        ...
    


class Double(Real):
    """
    Amazing documentation here.
    """
    def encode(self) -> TagList:
        """Encode a double as a tag list."""
        ...
    
    @classmethod
    def decode(cls, tag_list: TagList) -> Double:
        """Decode a double from a tag list."""
        ...
    


@bacpypes_debugging
class OctetString(Atomic, bytes):
    """
    Amazing documentation here.
    """
    _debug: Callable[..., None]
    _min_length: Optional[int]
    _max_length: Optional[int]
    @classmethod
    def cast(cls: type, arg: _Any) -> _Any:
        """Return True if arg is valid value for the class."""
        ...
    
    def encode(self) -> TagList:
        """Encode an octet string as a tag list."""
        ...
    
    @classmethod
    def decode(cls, tag_list: TagList) -> OctetString:
        """
        Decode an octet string from a tag.  Note that this overrides the
        bytes.decode() function, which can be called by bytes.decode(obj,...).
        """
        ...
    


@bacpypes_debugging
class CharacterString(Atomic, str):
    """
    Amazing documentation here.
    """
    _debug: Callable[..., None]
    _encoding: int = ...
    _min_length: Optional[int]
    _max_length: Optional[int]
    @classmethod
    def cast(cls: type, arg: _Any) -> _Any:
        """Return True if arg is valid value for the class."""
        ...
    
    def encode(self) -> TagList:
        """
        Encode the character string as a tag.  Note that this overrides the
        str.encode() function, which can be called by str.encode(obj,...).
        """
        ...
    
    @classmethod
    def decode(cls, tag_list: TagList) -> CharacterString:
        """Decode a character string from a tag."""
        ...
    


@bacpypes_debugging
class BitStringMetaclass(ElementMetaclass):
    """
    Amazing documentation here.
    """
    _debug: Callable[..., None]
    def __new__(cls: _Any, clsname: str, superclasses: Tuple[type, ...], attributedict: Dict[str, _Any]) -> BitStringMetaclass:
        ...
    
    def __call__(cls, *args: _Any, **kwargs: _Any) -> BitString:
        ...
    


@bacpypes_debugging
class BitString(Atomic, list, metaclass=BitStringMetaclass):
    """
    Amazing documentation here.
    """
    _debug: Callable[..., None]
    _bitstring_names: Dict[str, int] = ...
    _bitstring_length: int
    @classmethod
    def cast(cls: type, arg: _Any) -> _Any:
        ...
    
    def __getitem__(self, item: Union[int, str]) -> int:
        ...
    
    def __setitem__(self, item: Union[int, str], value: int) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def encode(self) -> TagList:
        """Encode an octet string as a tag list."""
        ...
    
    @classmethod
    def decode(cls, tag_list: TagList) -> BitString:
        """
        Decode a bit string from a tag.  Note that this overrides the
        bytes.decode() function, which can be called by bytes.decode(obj,...).
        """
        ...
    


@bacpypes_debugging
class EnumeratedMetaclass(ElementMetaclass):
    """
    Amazing documentation here.
    """
    _debug: Callable[..., None]
    def __new__(cls: _Any, clsname: str, superclasses: Tuple[type, ...], attributedict: Dict[str, _Any]) -> EnumeratedMetaclass:
        ...
    
    def __call__(cls, *args: _Any, **kwargs: _Any) -> Enumerated:
        ...
    


@bacpypes_debugging
class Enumerated(Atomic, int, metaclass=EnumeratedMetaclass):
    """
    Amazing documentation here.
    """
    _debug: Callable[..., None]
    _enum_map: Dict[str, int] = ...
    _attr_map: Dict[int, str]
    _asn1_map: Dict[int, str]
    _low_limit: int = ...
    _high_limit: Optional[int] = ...
    @classmethod
    def cast(cls: type, arg: _Any) -> _Any:
        """Return True if arg is valid value for the class."""
        ...
    
    @property
    def attr(self) -> str:
        ...
    
    @property
    def asn1(self) -> str:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def encode(self) -> TagList:
        """Encode an enumerated element as a tag list."""
        ...
    
    @classmethod
    def decode(cls, tag_list: TagList) -> Enumerated:
        """Decode an enumerated element from a tag list."""
        ...
    


_mm = ...
_dd = ...
_yy = ...
_yyyy = ...
_dow = ...
_special_mon = ...
_special_mon_inv = ...
_special_day = ...
_special_day_inv = ...
_special_dow = ...
_special_dow_inv = ...
_date_patterns = ...
@bacpypes_debugging
class Date(Atomic, tuple):
    """
    Amazing documentation here.
    """
    _debug: Callable[..., None]
    @classmethod
    def cast(cls: type, arg: _Any) -> _Any:
        """Return True if arg is valid value for the class."""
        ...
    
    @classmethod
    def now(cls: type, when: Optional[float] = ...) -> Date:
        """Set the current value to the correct tuple based on the seconds
        since the epoch.
        """
        ...
    
    @property
    def is_special(self) -> bool:
        """Date has wildcard values."""
        ...
    
    @property
    def date(self) -> datetime.date:
        """Return the value as a datetime.date object."""
        ...
    
    def isoformat(self) -> str:
        ...
    
    @classmethod
    def fromisoformat(cls: type, date_string: str) -> Date:
        ...
    
    def __str__(self) -> str:
        """String representation of the date."""
        ...
    
    def encode(self) -> TagList:
        """Encode an enumerated element as a tag list."""
        ...
    
    @classmethod
    def decode(cls, tag_list: TagList) -> Date:
        """Decode an enumerated element from a tag list."""
        ...
    


_time_regex = ...
@bacpypes_debugging
class Time(Atomic, tuple):
    """
    Amazing documentation here.
    """
    _debug: Callable[..., None]
    @classmethod
    def cast(cls: type, arg: _Any) -> _Any:
        """Return True if arg is valid value for the class."""
        ...
    
    @classmethod
    def now(cls: type, when: Optional[float] = ...) -> Time:
        """
        Set the current value to the correct tuple based on the seconds
        since the epoch.
        """
        ...
    
    @property
    def is_special(self) -> bool:
        """Date has wildcard values."""
        ...
    
    @property
    def time(self) -> datetime.time:
        """Return the value as a datetime.time object."""
        ...
    
    def isoformat(self) -> str:
        ...
    
    @classmethod
    def fromisoformat(cls: type, time_string: str) -> Time:
        ...
    
    def __str__(self) -> str:
        ...
    
    def encode(self) -> TagList:
        """Encode an enumerated element as a tag list."""
        ...
    
    @classmethod
    def decode(cls, tag_list: TagList) -> Time:
        """Decode an enumerated element from a tag list."""
        ...
    


class ObjectType(Enumerated):
    _vendor_range = ...
    _high_limit: int = ...
    accessCredential = ...
    accessDoor = ...
    accessPoint = ...
    accessRights = ...
    accessUser = ...
    accessZone = ...
    accumulator = ...
    alertEnrollment = ...
    analogInput = ...
    analogOutput = ...
    analogValue = ...
    auditLog = ...
    auditReporter = ...
    averaging = ...
    binaryInput = ...
    binaryLightingOutput = ...
    binaryOutput = ...
    binaryValue = ...
    bitstringValue = ...
    calendar = ...
    channel = ...
    characterstringValue = ...
    command = ...
    credentialDataInput = ...
    datePatternValue = ...
    dateValue = ...
    datetimePatternValue = ...
    datetimeValue = ...
    device = ...
    elevatorGroup = ...
    escalator = ...
    eventEnrollment = ...
    eventLog = ...
    file = ...
    globalGroup = ...
    group = ...
    integerValue = ...
    largeAnalogValue = ...
    lifeSafetyPoint = ...
    lifeSafetyZone = ...
    lift = ...
    lightingOutput = ...
    loadControl = ...
    loop = ...
    multiStateInput = ...
    multiStateOutput = ...
    multiStateValue = ...
    networkSecurity = ...
    networkPort = ...
    notificationClass = ...
    notificationForwarder = ...
    octetstringValue = ...
    positiveIntegerValue = ...
    program = ...
    pulseConverter = ...
    schedule = ...
    staging = ...
    structuredView = ...
    timePatternValue = ...
    timeValue = ...
    timer = ...
    trendLog = ...
    trendLogMultiple = ...


class PropertyIdentifier(Enumerated):
    _vendor_range = ...
    absenteeLimit = ...
    acceptedModes = ...
    accessAlarmEvents = ...
    accessDoors = ...
    accessEvent = ...
    accessEventAuthenticationFactor = ...
    accessEventCredential = ...
    accessEventTag = ...
    accessEventTime = ...
    accessTransactionEvents = ...
    accompaniment = ...
    accompanimentTime = ...
    ackedTransitions = ...
    ackRequired = ...
    action = ...
    actionText = ...
    activationTime = ...
    activeAuthenticationPolicy = ...
    activeCovMultipleSubscriptions = ...
    activeCovSubscriptions = ...
    activeText = ...
    activeVtSessions = ...
    actualShedLevel = ...
    adjustValue = ...
    alarmValue = ...
    alarmValues = ...
    alignIntervals = ...
    all = ...
    allowGroupDelayInhibit = ...
    allWritesSuccessful = ...
    apduLength = ...
    apduSegmentTimeout = ...
    apduTimeout = ...
    applicationSoftwareVersion = ...
    archive = ...
    assignedAccessRights = ...
    assignedLandingCalls = ...
    attemptedSamples = ...
    auditableOperations = ...
    auditLevel = ...
    auditNotificationRecipient = ...
    auditPriorityFilter = ...
    auditSourceReporter = ...
    authenticationFactors = ...
    authenticationPolicyList = ...
    authenticationPolicyNames = ...
    authenticationStatus = ...
    authorizationExemptions = ...
    authorizationMode = ...
    autoSlaveDiscovery = ...
    averageValue = ...
    backupAndRestoreState = ...
    backupFailureTimeout = ...
    backupPreparationTime = ...
    bacnetIPGlobalAddress = ...
    bacnetIPMode = ...
    bacnetIPMulticastAddress = ...
    bacnetIPNATTraversal = ...
    bacnetIPUDPPort = ...
    bacnetIPv6Mode = ...
    bacnetIPv6MulticastAddress = ...
    bacnetIPv6UDPPort = ...
    baseDeviceSecurityPolicy = ...
    bbmdAcceptFDRegistrations = ...
    bbmdBroadcastDistributionTable = ...
    bbmdForeignDeviceTable = ...
    belongsTo = ...
    bias = ...
    bitMask = ...
    bitText = ...
    blinkWarnEnable = ...
    bufferSize = ...
    carAssignedDirection = ...
    carDoorCommand = ...
    carDoorStatus = ...
    carDoorText = ...
    carDoorZone = ...
    carDriveStatus = ...
    carLoad = ...
    carLoadUnits = ...
    carMode = ...
    carMovingDirection = ...
    carPosition = ...
    changeOfStateCount = ...
    changeOfStateTime = ...
    changesPending = ...
    channelNumber = ...
    clientCovIncrement = ...
    command = ...
    commandTimeArray = ...
    configurationFiles = ...
    controlGroups = ...
    controlledVariableReference = ...
    controlledVariableUnits = ...
    controlledVariableValue = ...
    count = ...
    countBeforeChange = ...
    countChangeTime = ...
    covIncrement = ...
    covPeriod = ...
    covResubscriptionInterval = ...
    covuPeriod = ...
    covuRecipients = ...
    credentialDisable = ...
    credentials = ...
    credentialsInZone = ...
    credentialStatus = ...
    currentCommandPriority = ...
    databaseRevision = ...
    dateList = ...
    daylightSavingsStatus = ...
    daysRemaining = ...
    deadband = ...
    defaultFadeTime = ...
    defaultPresentValue = ...
    defaultRampRate = ...
    defaultStepIncrement = ...
    defaultSubordinateRelationship = ...
    defaultTimeout = ...
    deleteOnForward = ...
    deployedProfileLocation = ...
    derivativeConstant = ...
    derivativeConstantUnits = ...
    description = ...
    descriptionOfHalt = ...
    deviceAddressBinding = ...
    deviceType = ...
    deviceUUID = ...
    directReading = ...
    distributionKeyRevision = ...
    doNotHide = ...
    doorAlarmState = ...
    doorExtendedPulseTime = ...
    doorMembers = ...
    doorOpenTooLongTime = ...
    doorPulseTime = ...
    doorStatus = ...
    doorUnlockDelayTime = ...
    dutyWindow = ...
    effectivePeriod = ...
    egressActive = ...
    egressTime = ...
    elapsedActiveTime = ...
    elevatorGroup = ...
    enable = ...
    energyMeter = ...
    energyMeterRef = ...
    entryPoints = ...
    errorLimit = ...
    escalatorMode = ...
    eventAlgorithmInhibit = ...
    eventAlgorithmInhibitRef = ...
    eventDetectionEnable = ...
    eventEnable = ...
    eventMessageTexts = ...
    eventMessageTextsConfig = ...
    eventParameters = ...
    eventState = ...
    eventTimeStamps = ...
    eventType = ...
    exceptionSchedule = ...
    executionDelay = ...
    exitPoints = ...
    expectedShedLevel = ...
    expirationTime = ...
    extendedTimeEnable = ...
    failedAttemptEvents = ...
    failedAttempts = ...
    failedAttemptsTime = ...
    faultHighLimit = ...
    faultLowLimit = ...
    faultParameters = ...
    faultSignals = ...
    faultType = ...
    faultValues = ...
    fdBBMDAddress = ...
    fdSubscriptionLifetime = ...
    feedbackValue = ...
    fileAccessMethod = ...
    fileSize = ...
    fileType = ...
    firmwareRevision = ...
    floorNumber = ...
    floorText = ...
    fullDutyBaseline = ...
    globalIdentifier = ...
    groupID = ...
    groupMemberNames = ...
    groupMembers = ...
    groupMode = ...
    higherDeck = ...
    highLimit = ...
    inactiveText = ...
    initialTimeout = ...
    inProcess = ...
    inProgress = ...
    inputReference = ...
    installationID = ...
    instanceOf = ...
    instantaneousPower = ...
    integralConstant = ...
    integralConstantUnits = ...
    interfaceValue = ...
    intervalOffset = ...
    ipAddress = ...
    ipDefaultGateway = ...
    ipDHCPEnable = ...
    ipDHCPLeaseTime = ...
    ipDHCPLeaseTimeRemaining = ...
    ipDHCPServer = ...
    ipDNSServer = ...
    ipSubnetMask = ...
    ipv6Address = ...
    ipv6AutoAddressingEnable = ...
    ipv6DefaultGateway = ...
    ipv6DHCPLeaseTime = ...
    ipv6DHCPLeaseTimeRemaining = ...
    ipv6DHCPServer = ...
    ipv6DNSServer = ...
    ipv6PrefixLength = ...
    ipv6ZoneIndex = ...
    issueConfirmedNotifications = ...
    isUTC = ...
    keySets = ...
    landingCallControl = ...
    landingCalls = ...
    landingDoorStatus = ...
    lastAccessEvent = ...
    lastAccessPoint = ...
    lastCommandTime = ...
    lastCredentialAdded = ...
    lastCredentialAddedTime = ...
    lastCredentialRemoved = ...
    lastCredentialRemovedTime = ...
    lastKeyServer = ...
    lastNotifyRecord = ...
    lastPriority = ...
    lastRestartReason = ...
    lastRestoreTime = ...
    lastStateChange = ...
    lastUseTime = ...
    lifeSafetyAlarmValues = ...
    lightingCommand = ...
    lightingCommandDefaultPriority = ...
    limitEnable = ...
    limitMonitoringInterval = ...
    linkSpeed = ...
    linkSpeedAutonegotiate = ...
    linkSpeeds = ...
    listOfGroupMembers = ...
    listOfObjectPropertyReferences = ...
    listOfSessionKeys = ...
    localDate = ...
    localForwardingOnly = ...
    localTime = ...
    location = ...
    lockout = ...
    lockoutRelinquishTime = ...
    lockStatus = ...
    logBuffer = ...
    logDeviceObjectProperty = ...
    loggingObject = ...
    loggingRecord = ...
    loggingType = ...
    logInterval = ...
    lowDiffLimit = ...
    lowerDeck = ...
    lowLimit = ...
    macAddress = ...
    machineRoomID = ...
    maintenanceRequired = ...
    makingCarCall = ...
    manipulatedVariableReference = ...
    manualSlaveAddressBinding = ...
    maskedAlarmValues = ...
    masterExemption = ...
    maxActualValue = ...
    maxApduLengthAccepted = ...
    maxFailedAttempts = ...
    maximumOutput = ...
    maximumSendDelay = ...
    maximumValue = ...
    maximumValueTimestamp = ...
    maxInfoFrames = ...
    maxMaster = ...
    maxPresValue = ...
    maxSegmentsAccepted = ...
    memberOf = ...
    members = ...
    memberStatusFlags = ...
    minActualValue = ...
    minimumOffTime = ...
    minimumOnTime = ...
    minimumOutput = ...
    minimumValue = ...
    minimumValueTimestamp = ...
    minPresValue = ...
    mode = ...
    modelName = ...
    modificationDate = ...
    monitoredObjects = ...
    musterPoint = ...
    negativeAccessRules = ...
    networkAccessSecurityPolicies = ...
    networkInterfaceName = ...
    networkNumber = ...
    networkNumberQuality = ...
    networkType = ...
    nextStoppingFloor = ...
    nodeSubtype = ...
    nodeType = ...
    notificationClass = ...
    notificationThreshold = ...
    notifyType = ...
    numberOfApduRetries = ...
    numberOfAuthenticationPolicies = ...
    numberOfStates = ...
    objectIdentifier = ...
    objectList = ...
    objectName = ...
    objectPropertyReference = ...
    objectType = ...
    occupancyCount = ...
    occupancyCountAdjust = ...
    occupancyCountEnable = ...
    occupancyExemption = ...
    occupancyLowerLimit = ...
    occupancyLowerLimitEnforced = ...
    occupancyState = ...
    occupancyUpperLimit = ...
    occupancyUpperLimitEnforced = ...
    operationDirection = ...
    operationExpected = ...
    optional = ...
    outOfService = ...
    outputUnits = ...
    packetReorderTime = ...
    passbackExemption = ...
    passbackMode = ...
    passbackTimeout = ...
    passengerAlarm = ...
    polarity = ...
    portFilter = ...
    positiveAccessRules = ...
    power = ...
    powerMode = ...
    prescale = ...
    presentStage = ...
    presentValue = ...
    priority = ...
    priorityArray = ...
    priorityForWriting = ...
    processIdentifier = ...
    processIdentifierFilter = ...
    profileLocation = ...
    profileName = ...
    programChange = ...
    programLocation = ...
    programState = ...
    propertyList = ...
    proportionalConstant = ...
    proportionalConstantUnits = ...
    protocolLevel = ...
    protocolObjectTypesSupported = ...
    protocolRevision = ...
    protocolServicesSupported = ...
    protocolVersion = ...
    pulseRate = ...
    readOnly = ...
    reasonForDisable = ...
    reasonForHalt = ...
    recipientList = ...
    recordCount = ...
    recordsSinceNotification = ...
    referencePort = ...
    registeredCarCall = ...
    reliability = ...
    reliabilityEvaluationInhibit = ...
    relinquishDefault = ...
    represents = ...
    requestedShedLevel = ...
    requestedUpdateInterval = ...
    required = ...
    resolution = ...
    restartNotificationRecipients = ...
    restoreCompletionTime = ...
    restorePreparationTime = ...
    routingTable = ...
    scale = ...
    scaleFactor = ...
    scheduleDefault = ...
    securedStatus = ...
    securityPDUTimeout = ...
    securityTimeWindow = ...
    segmentationSupported = ...
    sendNow = ...
    serialNumber = ...
    setpoint = ...
    setpointReference = ...
    setting = ...
    shedDuration = ...
    shedLevelDescriptions = ...
    shedLevels = ...
    silenced = ...
    slaveAddressBinding = ...
    slaveProxyEnable = ...
    stageNames = ...
    stages = ...
    startTime = ...
    stateChangeValues = ...
    stateDescription = ...
    stateText = ...
    statusFlags = ...
    stopTime = ...
    stopWhenFull = ...
    strikeCount = ...
    structuredObjectList = ...
    subordinateAnnotations = ...
    subordinateList = ...
    subordinateNodeTypes = ...
    subordinateRelationships = ...
    subordinateTags = ...
    subscribedRecipients = ...
    supportedFormatClasses = ...
    supportedFormats = ...
    supportedSecurityAlgorithms = ...
    systemStatus = ...
    tags = ...
    targetReferences = ...
    threatAuthority = ...
    threatLevel = ...
    timeDelay = ...
    timeDelayNormal = ...
    timeOfActiveTimeReset = ...
    timeOfDeviceRestart = ...
    timeOfStateCountReset = ...
    timeOfStrikeCountReset = ...
    timerRunning = ...
    timerState = ...
    timeSynchronizationInterval = ...
    timeSynchronizationRecipients = ...
    totalRecordCount = ...
    traceFlag = ...
    trackingValue = ...
    transactionNotificationClass = ...
    transition = ...
    trigger = ...
    units = ...
    updateInterval = ...
    updateKeySetTimeout = ...
    updateTime = ...
    userExternalIdentifier = ...
    userInformationReference = ...
    userName = ...
    userType = ...
    usesRemaining = ...
    utcOffset = ...
    utcTimeSynchronizationRecipients = ...
    validSamples = ...
    valueBeforeChange = ...
    valueChangeTime = ...
    valueSet = ...
    valueSource = ...
    valueSourceArray = ...
    varianceValue = ...
    vendorIdentifier = ...
    vendorName = ...
    verificationTime = ...
    virtualMACAddressTable = ...
    vtClassesSupported = ...
    weeklySchedule = ...
    windowInterval = ...
    windowSamples = ...
    writeStatus = ...
    zoneFrom = ...
    zoneMembers = ...
    zoneTo = ...


@bacpypes_debugging
class ObjectIdentifier(Atomic, tuple):
    """
    Amazing documentation here.
    """
    _debug: Callable[..., None]
    object_type_class: type = ...
    @classmethod
    def cast(cls: type, arg: _Any) -> _Any:
        """Return True if arg is valid value for the class."""
        ...
    
    def __int__(self) -> int:
        """Return the object identifier as a integer."""
        ...
    
    def __str__(self) -> str:
        """Return a string of the form 'type,instance'."""
        ...
    
    def encode(self) -> TagList:
        """Encode an enumerated element as a tag list."""
        ...
    
    @classmethod
    def decode(cls, tag_list: TagList) -> ObjectIdentifier:
        """Decode an enumerated element from a tag list."""
        ...
    


